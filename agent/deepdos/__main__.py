"""
    The main functionality of deepdos
"""
import os

from deepdos.args import parse_args
from deepdos.conf import ETC_DIR, create_logger, load_conf, LR_MODEL
from deepdos.data import load_model, parse_flow_data
from deepdos.utils.network import create_firewall, examine_flow_packets
from deepdos.utils.processes import (proc_capture_pcap,
                                     proc_execute_cicflowmeter)

import requests

import socket


HOST = '0.0.0.0'  # Standard loopback interface address (localhost)
PORT = 65432

AGENT_ID = "PC_3"

class DeepDos:
    """
        The Deepdos executor and class manager
    """

    def __init__(self, options: dict):
        # Init data
        self.running = True
        self.model_ml_lr = load_model(model_path=LR_MODEL)#options["model_type"])
        self.interface = options["interface"]
        self.interface_data = options["interface_data"]
        self.ip_v4 = self.interface_data["2"]["address"]
        self.active_firewall = options["firewall"]
        self.logger = create_logger(__name__, options["log"])

        # Predictions file
        self.flow_file = open(f"{ETC_DIR}/logs/flow_file.txt", "w+")

        # Setup the firewall
        if self.active_firewall:
            self.firewall = create_firewall(
                self.interface,
                self.interface_data,
                self.active_firewall,
                options["naughty_count"],
            )

            if not self.firewall:
                self.logger.info("Need to be root in order to create the Firewall")
        else:
            self.firewall = None

    def capture_network_data(self):
        """
            Write pcap data
        """
        pcap_file = open(f"{ETC_DIR}/pcap_info/out.pcap", "w", encoding="ISO-8859-1")
        pcap_list = proc_capture_pcap(self.interface)

        # The counter controls the amount of writes that occur.
        self.logger.info("Writing packet data to out.pcap file")
        pcap_file.writelines(pcap_list)
        pcap_file.close()

        # Execute cicflowmeter
        self.logger.info("Generating CSV from out.pcap")
        proc_execute_cicflowmeter(ETC_DIR)

    def evaluate_network_data(self):
        """
            Load the flow data generated by the cicflowmeter, classify the flow data,
            and then take action with the firewall if needed.

            Returns:
                The output logs of examining the flow packets
        """
        try:
            # Parse the flow data
            flow_data = parse_flow_data()
        except ValueError:
            raise ValueError("too little flow")

        # Grab data out of model processor
        flow_features = flow_data["data"]
        flow_metadata = flow_data["metadata"]
        flow_metadata_dict = flow_data["metadata_dict"]

        # print("flow_metadata", flow_metadata["from_ip"])
        # Run model predictions
        result = self.model_ml_lr.predict(flow_features)
        proba = self.model_ml_lr.predict_proba(flow_features)
        # print("result", result)
        # print("proba", proba)
        
        flow_metadata_dict["proba"] = proba.tolist()
        flow_metadata_dict["agent_id"] = AGENT_ID

        # print(flow_metadata_dict)
        r = requests.post("http://192.168.1.2:8000/api/traffic/update", json=flow_metadata_dict)
        print(r)

        # Flag Ip flow
        result_data = flow_metadata, result, proba
        malicious_flows, flow_logs = examine_flow_packets(result_data, self.ip_v4)

        # If there is an active firewall, track all malicious flows
        if self.firewall:
            self.firewall.track_flows(malicious_flows)
        return flow_logs


    def monitor(self):
        try:
            # Capture network data and then evaluate it
            self.capture_network_data()
            flow_logs = self.evaluate_network_data()

            # Write to the flow file and remove the old pcap file
            self.flow_file.writelines(line + "\n" for line in flow_logs[0])
            self.flow_file.flush()
            os.remove(f"{ETC_DIR}/pcap_info/out.pcap")

        except ValueError as exception:
            # Handle flow error
            if exception.args[0] == "too little flow":
                self.logger.warning("Not enough flow generated, restarting process")
                monitor()

    def main_loop(self):
        """
            Enter the main loop of the program, executing the sub processes
            and executing model commands
        """

        
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind((HOST, PORT))
            s.listen()

            while True:
                conn, addr = s.accept()
                with conn:
                    print('Connected by', addr)
                    data = conn.recv(1024)
                    # print(data)
                    if data == b"monitor_on":
                        print("Activate monitor ...")
                        self.monitor()
                    
                    conn.sendall(b"monitor_done")

            s.close()

        # Execute the main loop
        # while self.running:
        #     try:
        #         # Capture network data and then evaluate it
        #         self.capture_network_data()
        #         flow_logs = self.evaluate_network_data()

        #         # Write to the flow file and remove the old pcap file
        #         self.flow_file.writelines(line + "\n" for line in flow_logs[0])
        #         self.flow_file.flush()
        #         os.remove(f"{ETC_DIR}/pcap_info/out.pcap")

        #     except ValueError as exception:
        #         # Handle flow error
        #         if exception.args[0] == "too little flow":
        #             self.logger.warning("Not enough flow generated, restarting process")


def start_execution():
    """
        Parse arguments and run our deepdos application
    """
    # Parse all options for deepdos
    options = parse_args()
    # Instantiate logging

    # Load config file
    load_conf()

    # Execute deepdos mainloop
    DeepDos(options).main_loop()


if __name__ == "__main__":

    start_execution()
